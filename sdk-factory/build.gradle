buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'org.yaml:snakeyaml:2.0'
    }
}

import org.yaml.snakeyaml.Yaml

// ==================== è¾…åŠ©æ–¹æ³• ====================

/**
 * å¤„ç†æ¡ä»¶ç¼–è¯‘æ ‡è®°
 */
def processConditional(String content, String tag, boolean condition) {
    def pattern = ~/(?s)\{\{#${tag}\}\}(.*?)\{\{\/${tag}\}\}/
    if (condition) {
        return content.replaceAll(pattern) { match -> match[1] }
    } else {
        return content.replaceAll(pattern, '')
    }
}

// ==================== ä»»åŠ¡1ï¼šç”Ÿæˆæºç  ====================

task generateClientSources {
    group = 'sdk-factory'
    description = 'Generate customized SDK sources for all clients'
    
    doLast {
        def yaml = new Yaml()
        def clientsDir = file('clients')
        def templateDir = file('sdk-template')
        
        // è¯»å–ç‰ˆæœ¬é…ç½®
        def versionsConfig = yaml.load(file('clients/versions.yaml').newReader())
        def globalVersion = versionsConfig.global.sdk_version
        
        // å¤„ç†æ¯ä¸ªå®¢æˆ·é…ç½®
        clientsDir.listFiles().findAll { 
            it.name.endsWith('.yaml') && it.name != 'versions.yaml' && it.name != 'template.yaml'
        }.each { configFile ->
            def config = yaml.load(configFile.newReader())
            
            def clientId = config.client.id
            def clientName = config.client.name
            def basePackage = config.packages.base
            def publicPackage = config.packages.public
            def mainClass = config.classes.main
            def coreClass = config.classes.core
            def analyticsClass = config.classes.analytics
            def adsClass = config.classes.ads
            
            // è·å–ç‰ˆæœ¬
            def version = versionsConfig.overrides?."${clientId}"?.sdk_version ?: globalVersion
            
            // åŠŸèƒ½å¼€å…³
            def enableAnalytics = config.features.enable_analytics
            def enableAds = config.features.enable_ads
            
            def outputDir = file("generated/${clientId}-sdk/src/main/kotlin")
            
            println '=' * 60
            println "Generating sources for: ${clientName} (${clientId})"
            println '=' * 60
            
            // æ¸…ç†æ—§æ–‡ä»¶
            delete outputDir
            outputDir.mkdirs()
            
            // éå†æ¨¡æ¿æ–‡ä»¶
            fileTree(templateDir).matching {
                include '**/*.kt'
            }.each { templateFile ->
                // 1. è¯»å–å¹¶æ›¿æ¢å†…å®¹
                def content = templateFile.text
                
                // åŸºç¡€æ›¿æ¢
                content = content
                    .replace('{{BASE_PACKAGE}}', basePackage)
                    .replace('{{CLIENT_PACKAGE}}', publicPackage)
                    .replace('{{SDK_NAME}}', coreClass)
                    .replace('{{CLIENT_SDK_NAME}}', mainClass)
                    .replace('{{CLIENT_NAME}}', clientName)
                    .replace('{{VERSION}}', version)
                    .replace('{{ANALYTICS_CLASS}}', analyticsClass)
                    .replace('{{ADS_CLASS}}', adsClass)
                
                // æ¡ä»¶ç¼–è¯‘å¤„ç†
                content = processConditional(content, 'IF_FEATURE_ANALYTICS', enableAnalytics)
                content = processConditional(content, 'IF_FEATURE_ADS', enableAds)
                
                // 2. è®¡ç®—è¾“å‡ºè·¯å¾„
                def relativePath = templateFile.path.replace(templateDir.path + File.separator, '')
                def targetPath = relativePath
                    .replace('{{BASE_PACKAGE}}', basePackage.replace('.', File.separator))
                    .replace('{{CLIENT_PACKAGE}}', publicPackage.replace('.', File.separator))
                    .replace('{{SDK_NAME}}', coreClass)
                    .replace('{{CLIENT_SDK_NAME}}', mainClass)
                    .replace('{{ANALYTICS_CLASS}}', analyticsClass)
                    .replace('{{ADS_CLASS}}', adsClass)
                
                def targetFile = new File(outputDir, targetPath)
                targetFile.parentFile.mkdirs()
                targetFile.text = content
                
                println "  âœ“ ${targetFile.path.replace(file('generated').path + File.separator, '')}"
            }
            
            println "âœ… Generated sources for ${clientName}\n"
        }
    }
}

// ==================== ä»»åŠ¡2ï¼šç”Ÿæˆæ··æ·†è§„åˆ™ ====================

task generateProguardRules {
    group = 'sdk-factory'
    description = 'Generate customized ProGuard rules for all clients'
    
    dependsOn 'generateClientSources'
    
    doLast {
        def yaml = new Yaml()
        def clientsDir = file('clients')
        
        clientsDir.listFiles().findAll { 
            it.name.endsWith('.yaml') && it.name != 'versions.yaml' && it.name != 'template.yaml'
        }.each { configFile ->
            def config = yaml.load(configFile.newReader())
            
            def clientId = config.client.id
            def clientName = config.client.name
            def publicPackage = config.packages.public
            def basePackage = config.packages.base
            def internalPackage = config.packages.internal
            def mainClass = config.classes.main
            
            def obfuscation = config.obfuscation ?: [:]
            def proguard = obfuscation.proguard ?: [:]
            
            def dictionary = proguard.dictionary ?: ''
            def seed = proguard.seed ?: 'default_seed'
            def optimizationPasses = proguard.optimization_passes ?: 5
            
            def outputDir = file("generated/${clientId}-sdk")
            outputDir.mkdirs()
            
            def proguardFile = new File(outputDir, 'proguard-rules.pro')
            
            proguardFile.text = """# ==================== ${clientName} SDK æ··æ·†è§„åˆ™ ====================
# ç”Ÿæˆæ—¶é—´: ${new Date()}
# SDKç‰ˆæœ¬: ${config.maven.version}

# ==================== 1. ä¿ç•™å…¬å…±API ====================
-keep public class ${publicPackage}.${mainClass} {
    public <methods>;
    public <fields>;
}

# âœ… ä¿ç•™å…¬å…±æ¥å£
-keep public interface ${publicPackage}.** { *; }

# âœ… ä¿ç•™æ³¨è§£
-keepattributes *Annotation*

# ==================== 2. æ··æ·†å†…éƒ¨å®ç° ====================
-keep,allowobfuscation class ${basePackage}.** { *; }
-keep,allowobfuscation class ${internalPackage}.** { *; }

# ==================== 3. æ¿€è¿›æ··æ·†é€‰é¡¹ ====================
-overloadaggressively
-repackageclasses ''
-allowaccessmodification
-mergeinterfacesaggressively
-optimizationpasses ${optimizationPasses}

# ==================== 4. è‡ªå®šä¹‰æ··æ·†å­—å…¸ ====================
${dictionary ? "-obfuscationdictionary clients/${dictionary}\n-classobfuscationdictionary clients/${dictionary}\n-packageobfuscationdictionary clients/${dictionary}" : ''}

# ==================== 5. è‡ªå®šä¹‰Seed ====================
-adaptclassstrings ${seed}

# ==================== 6. ç§»é™¤è°ƒè¯•ä¿¡æ¯ ====================
-assumenosideeffects class android.util.Log {
    public static *** d(...);
    public static *** v(...);
    public static *** i(...);
    public static *** w(...);
    public static *** e(...);
}

-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable

# ==================== 7. Kotlinç›¸å…³ ====================
-keep class kotlin.Metadata { *; }
-keepclassmembernames class kotlinx.** {
    volatile <fields>;
}

# ==================== 8. Androidç»„ä»¶ä¿ç•™ ====================
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider

# ==================== 9. ç¬¬ä¸‰æ–¹SDKè§„åˆ™ ====================
-dontwarn **

# ==================== 10. ä¿ç•™æ³¨è§£æ ‡è®° ====================
-keep class * {
    @androidx.annotation.Keep *;
}

-keepclassmembers class * {
    @androidx.annotation.Keep *;
}
""".stripIndent()
            
            println "âœ… Generated ProGuard rules for ${clientId}"
        }
    }
}

// ==================== ä»»åŠ¡3ï¼šåˆ—å‡ºæ‰€æœ‰å®¢æˆ· ====================

task listClients {
    group = 'sdk-factory'
    description = 'List all configured clients'
    
    doLast {
        def yaml = new Yaml()
        
        println '\n' + ('=' * 60)
        println 'Configured Clients:'
        println '=' * 60
        
        file('clients').listFiles().findAll { 
            it.name.endsWith('.yaml') && it.name != 'versions.yaml' && it.name != 'template.yaml'
        }.each { configFile ->
            def config = yaml.load(configFile.newReader())
            
            def clientName = config.client.name
            def clientId = config.client.id
            def publicPackage = config.packages.public
            def maven = config.maven
            
            println "\nğŸ“¦ ${clientName} (${clientId})"
            println "   Package: ${publicPackage}"
            println "   Maven: ${maven.groupId}:${maven.artifactId}:${maven.version}"
            println "   Repository: ${maven.repository}"
        }
        
        println '\n' + ('=' * 60) + '\n'
    }
}

// ==================== ä»»åŠ¡4ï¼šæ„å»ºæ‰€æœ‰å®¢æˆ· ====================

task buildAllClients {
    group = 'sdk-factory'
    description = 'Generate sources and ProGuard rules for all clients'
    
    dependsOn 'generateClientSources'
    dependsOn 'generateProguardRules'
}

// ==================== ä»»åŠ¡5ï¼šæ¸…ç† ====================

task clean(type: Delete) {
    group = 'build'
    delete 'generated'
    delete 'build'
    
    doLast {
        println 'âœ… Cleaned generated and build directories'
    }
}
